HADOOP STUDY

MapReduce 기초다지기

MapReduce의 기본 개념 및 예제 프로그램은 MAPREDUCE.ver1브랜치에...

1. MapReduceJob의 실행단계
구성
MapReduceJob은 클라이언트가 잡 실행을 요청하는 단계
                ↓
    해당 잡이 초기화되는 단계
                ↓
잡을 실행하기위해 태스크를 할당하는 단계
                ↓
할당된 태스크가 실행되는 단계
                ↓
        잡이 완료되는 단계

1.1 잡 실행요청
클라이언트(MapReduceApplication)가 잡실행을 요청하면 아래와 같이 작업이 진행된다.

클라이언트가 org.apache.hadoop.mapreduce.Job의 waitForCompletion 메서드를 호출해 잡실행을 요청한다.
요청은 최종적으로는 Job내부의 JobClient컴포넌트에 전달된다.
                ↓
요청을 받은 JobClient는 잡트래커의 getNewJobId메서드를 호출해 새로운 잡의 ID를 요청한다.
                ↓
잡트래커는 요청을 받은 뒤 잡의 출력파일경로가 정상적인 경로인지 확인후 정상일 경우 ID를 발급해준다. (JobClient와 잡트래커는 RPC통신을 하며 JobSubmissionProtocol에 정의된 프로토콜을 사용)
                ↓
JobClient는 잡을 실행하는데 필요한 정보를 잡트래커와 태스크트래커에게 공유해야한다.
                ↓
따라서 HDFS에 입력스플릿정보, JobConf에 설정된 정보, 잡클래스파일 혹은 잡클래스가 포함된 jar파일등을 저장한다.
                ↓
JobClient는 잡트래커의 submitJob메서드를 실행해 잡 실행을 요청한다.

1.2 잡 초기화
잡트래커는 잡을 실행하기위해 초기 설정 작업을 한다.
흐름은 아래와 같다.

잡트래커는 잡의 상태 및 진행과정을 모니터링할 수 있는 JobInProgress를 생성한다.
                ↓
JobInProgress는 1.1의 잡 실행요청과정에서  HDFS에 등록한 잡 공통파일을 로컬로 복사한다.
                ↓
스플릿정보를 이용하여 맵태스크, 리듀스태스크 개수를 계산한다.
                ↓
잡의 실행상태를 RUNNING으로 설정한다.
                ↓
JobInProgress객체를 내뷰 큐인 Jobs에 등록한다.
                ↓
Jobs에 등록된 Job들은 스케쥴러에의해 소비된다.

1.3 태스크할당
태스크의 할당은 TaskScheduler에서 이루어진다.
TaskScheduler는 추상클래스로 이를 구현한 JobQueueTaskScheduler등의 여러 Scheduler가 제공된다.
태스크할당의 흐름은 아래와 같다.

태스크트래커는 3초에 한번씩 잡트래커에게 하트비트를 전송하여 자신의 상태를 알려준다.
                ↓
스케줄러는 하트비트를 확인한 후 내부 큐에서 태스크를 할당할 잡을 선택한다.
                ↓
선택한 잡에서 하나의 태스크를 선택한다.(잡의 선택은 적용한 스케줄러의 알고리즘에 맞게 선택된다.)
                ↓
스케줄러는 태스크를 선택한 후 해당 태스크트래커에게 태스크할당을 알려준다.
                ↓
잡트래커는 하트비트의 응답으로 하트비트Response를 전송한다. (하트비트Response에 태스크트래커에 지시할 내용이 설정되어있다.)

1.3.1 태스크할당규칙
스케줄러는 맵태스크와 리듀스태스크를 구분해 태스크를 할당한다.

1.3.1.1 맵태스크할당규칙
우선적으로 입력스플릿과 동일한 서버의 태스크를 선택한다.
이유는 네트워크를 통하지않고, 로컬디스크에 접근해서 높은 성능을 낼 수 있기 때문이다.
동일한 서버를 선택할 수 없을경우 동일한 랙의 태스크를 선택한다.

1.3.1.2 리듀스태스크할당규칙
리듀스태스크의 경우는 대부분 맵 태스크의 출력데이터를 네트워크로 받기때문에 태스크목록에 있는 순서대로 선택하게 됩니다.

1.4 태스크 실행
태스크트래커는 할당받은 태스크를 새로운 JVM에서 실행하게 된다.
MapReduce는 이를 차일드JVM이라고 표현한다.
이렇게 하는 이유는 JVM에서 버그가 발생했을경우 태스크트래커에게 영향을 미치지않는다.
따라서 안정적인 운영이 가능하다.
사용자가 원할경우 재사용을 하도록 할 수 있다.
태스크실행의 흐름은 아래와 같다.

태스크런쳐는 하트비트Response에서 태스크정보를 꺼내서 태스크를 모니터랑할 TaskInProgress를 생성한다.
                ↓
태스크트래커는 HDFS에 저장된 잡 공통 파일들을 로컬디렉터리로 복사한다.
                ↓
생성된 TaskInProgress는 태스크 실행 결과를 저장할 로컬디렉터리를 생성한다.
                ↓
생성된 디렉터리에 잡JAR파일을 풀어놓는다.
                ↓
TaskInProgress는 TaskRunner에게 태스크 실행을 요청한다.
                ↓
TaskRunner는 JVMManager에게 차일드JVM에서 태스크를 실행해줄것을 요청한다.
                ↓
JVMManager는 실행할 클래스명과 옵션을 설정한 후, 커맨드라인에서 차일드JVM을 실행한다.
                ↓
차일드JVM은 TaskUmbilicalProtocol인터페이스를 통해 태스크가 완료될때까지 JVMManager에게 진행과정을 주기적으로 알려준다.
                ↓
태스크트래커는 JVMManager가 받은 정보를 공유받아서 진행과정을 모니터링한다.
                ↓
사용자가 정의한 매퍼클래스 혹은 리듀서클래스가 실행된다.

1.5 잡 완료
잡 완료의 경우 아래의 흐름만 정리한다.

태스크트래커가 잡트래커에 전송하는 하트비트에는 완료된 태스크의 정보가 포한된다.
                ↓
잡트래커는 해당 잡이 실행한 전체 태스크의 완료 정보를 받게 될 경우 JobInProgress는 잡의 상태를 SUCCEEDED로 바꾼다. 장애가 나서 실패했다면 FAILED로 바꾼다.
                ↓
잡을 실행한 클라이언트와 JobClient는 잡이 완료될 때까지 대기하고 있는다. (JoClient는 잡트래커의 getJobStatus()를 호출해 상태를 계속 확인한다.)
                ↓
확인된 상태가 SUCCEEDED면 true, FAILED이면 false를 클라이언트에 전달한다.
                ↓
클라이언트는 최종결과를 출력한다.
